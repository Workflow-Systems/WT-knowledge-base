# Настройка postgresql.conf

Небольшое предисловие:

Вы можете найти автоматические настройки конфигурации для PostgreSQL, но очень часто 1-2 тонких настройки могут решить целые дни оптимизации. Все советы ниже работают для PostgreSQL 10.5 на Windows. Настройки \*nix подобных систем в некоторых местах будут другими. Для PostgreSQL 15+ некоторые настройки не нужны, а некоторые нужно считать иначе.

В этой статье перечислены 18 настроек, которые помогут оптимизировать работу базы данных на компьютере. Некоторые из них просто помогают избежать ошибок, которые создаются автогенераторами.

Информация собиралась из многих мест, но так как иногда для 1 настройки приходится пролистать с пяток статей, то и список источников информации выйдет примерно таким:

1. https://habr.com
2. https://postgresqlco.nf
3. https://postgrespro.ru
4. https://www.enterprisedb.com
5. https://www.postgresql.org
6. Самый опасный и оппозиционный ресурс Эрафии: https://www.youtube.com

Убедительная просьба: при работе с\покупке  SSD оценивайте его качество, так как некачественные SSD на операциях кеширования(которые часто происходят при работе баз данных), теряют скорость, иногда до отношения 1 к 10.

## Набор postgresql.conf для базовых настроек

Категория ждёт какого-то файлообменника

* 4Gb RAM SSD&#x20;
* 4Gb RAM HDD
* 8Gb RAM SSD&#x20;
* 8Gb RAM HDD
* 16Gb RAM SSD&#x20;
* 16Gb RAM HDD
* 32Gb RAM SSD&#x20;
* 32Gb RAM HDD

## Настройки

1. **max\_connections** - определяет кол-во **любых**(в том числе и IDLE) соединений. Так как каждый DataConnection в WorkflowSystems - отдельное соединение, то обычная форма легко может занять до 20-30 соединений. Слишком больше количество соединений в этой настройке - проблема. Каждое соединение - отдельный процесс, плюс неиспользуемое соединение всё равно хранится в структуре, что отведена под управление базой данных.&#x20;

Формула: {Количество пользователей} \* 30 + Сonst, где Const - небольшой запас.

2. **shared\_buffers** - определяет объём памяти, выделенный сервером для контроля, соединений, активных операций, кеширования данных и много другого. &#x20;

Формула:  от 15 до 25% RAM. Приоритет в большую сторону. Не больше 8 Гб.

3. **work\_mem** - определяет объём памяти, который будет выделен для **каждого** подзапроса, в котором задействована сортировка или хеш-таблицы. Хэш-таблицы вызываются довольно часто они хороши тем, что создают пары, составленные из ключа и значения, что создаёт детерминированное время получения значения, вне зависимости от величины таблицы. Практически любой запрос с JOIN создаёт хеш-таблицу. Если же подзапрос выходит за выделенную память, то он пишется во временный файл на жестком диске. Эта настройка категорически важна.&#x20;

Значение это настройки определяется как степень двойки, поэтому после расчётов рекомендуется понизить её до неё(например, если при расчёте вышло 1200 мб, можно смело опускать до 1Гб).

Тем не менее в нашей практике был случай, когда формулы ниже не подошли клиенту. Была ситуация: много маленьких запросов, которые потребляют по 5-10 мб, и 4 запроса, которые потребляют до 1Гб. И если установить согласно формулам, то выходило 16 мб, всё было замечательно, но не для этих 4 запросов, которые выводили всю систему в отказ. В итоге пришлось выставлять 1Гб на work\_mem. Это спасло ситуацию, но тем не менее, все остальные запросы стали подвисать, так как оперативной памяти стало не хватать.

Формула: RAM  / (2  \* max\_connections) Округляем до степени двойки вниз

Формула№2: (Ram \* 0.9 - shared\_buffers) / max\_connections Округляем до степени двойки вниз

Первая формула больше подходит для баз, где больше работы с отчетами, но на малом количестве пользователей.

В любом случае, если вы в день записываете 2-3 миллиона записей в 1 из таблиц, в которой есть несколько индексов, и делаете это огромными функциями, или запрашиваете отчёты, которые в оперативной памяти занимают 1Гб, значит нужно увеличивать оперативную память сервера, брать хороший процессор на 30+ ядер или менять подход к расчётам.

4. **maintenance\_work\_mem** - определяет объём памяти для операций обслуживания: AVTOVACUUM, VACUUM, CREATE INDEX, ALTER TABLE...

Формула: RAM \* 0.1 > 1920MB  ?  1920MB : RAM \* 0.1.

5. **effective\_cache\_size** - определяет объём памяти, доступной для кеширования. Параметр для планировщика запросов. Учитывается и shared\_buffers и кеш самой файловой системы

Формула: RAM \* 0.75

6. **random\_page\_cost** - определяет приблизительную стоимость чтения случайной страницы с диска.&#x20;

Значение для HDD = 4.0&#x20;

Значение для SSD = 1.0-1.1

Чтобы проверить тип вашего жесткого диска нужно нажать ALT+R и ввести dfrgui. Вам откроется окно Дефрагментации дисков, там в типе носителя будет указано что это за диск. Если тип носителя - твердотельный, значит это SSD, если нет - HDD.

7. **cpu\_index\_tuple\_cost** и **cpu\_operator\_cost** - обе настройки, могут повлиять на выбор оптимизатором работы через индексы. Если же сервер имеет слабый процессор или индексы на базе почти не используются, то лучше оставить стандартные значения

cpu\_index\_tuple\_cost = 0.001

cpu\_operator\_cost = 0.0005

8. **idle\_in\_transaction\_session\_timeout** - определяет время сброса транзакций в idle режиме. Освобождение памяти, блокировок, открывает слот подключения. По умолчанию стоит 0, но неплохим вариантом для неспешных клиентов, где не пишется супер много всего постоянно и нет проблемы с кол-вом подключением будет значение 1min

idle\_in\_transaction\_session\_timeout = 1min

9. **statement\_timeout** - определяет время в мс, через которое запрос должен быть уничтожен. На случай зависаний. Подходят оба варианта, по умолчанию второй. Но обычно рекомендуют не делать эту настройку в конфиге, а редактировать роль(как во втором варианте), под которой всё работает, если правильно выстроена политика ролей и пользователей. Если не хочется с этим разбираться, то оставить настройку закомментированной

statement\_timeout = 10 \* самый длинный запрос # вариант глобальной работы

ALTER ROLE wf\_sys\_user SET statement\_timeout = '55min'; # вариант с работой с ролями

10. **temp\_file\_limit** - размер временного файла на диске, которое может занять транзакция. Стоит отметить, что по умолчанию значение -1, означает, что любая транзакция может занимать сколько угодно места. Как правило, если на харде хватает места, то можно так и оставить, хотя в большинстве случаев 10gb более, чем достаточно для работы транзакции. В нашей практике уже случались ситуации, когда у клиента на рабочем компе на диске с базой было мало свободного места. Это выливалось в то, что у него стабильно улетала в отказ база.

temp\_file\_limit = 10GB

11. **synchronous\_commit** - Определяет, будет ли сервер при фиксировании транзакции ждать, пока записи из WAL сохранятся на диске, прежде чем сообщить клиенту об успешном завершении операции. значение `off` для этого параметра не угрожает целостности данных: сбой операционной системы или базы данных может привести к потере последних транзакций, считавшихся зафиксированными, но состояние базы данных будет точно таким же, как и в случае штатного прерывания этих транзакций. Если вы можете себе позволить потерю данных(в радиусе 400 мс), и у вас в самом деле высокие нагрузки, то попробуйте поставить значение off. Но пока что это пригодилось только на тестовых базах
12. **default\_statistics\_target** - влияет на статистику, которая используется для работы оптимизатора. Чем выше, тем дольше работа оптимизатора, но тем точнее он работает. Стандартное значение - 100, в большинстве случаев его хватает. Но как только база начала разрастаться и появились узкие места, лучше переключиться на 1000, чтобы оптимизатор тратил больше времени, но при этом выдавал нормальные планы

Значение: 100-1000

13. Асинхронное поведение(ниже настройки для процессоров, которые стоят в WorkFlowSystems):

* max\_worker\_processes = 2
* max\_parallel\_workers =2&#x20;
* max\_parallel\_workers\_per\_gather = 1

Самый простой способ - отключить эти настройки.

max\_parallel\_workers = 0

Самый правильный способ - настроить по формулам ниже:

max\_background\_workers = Cores + (константа, если есть extensions для параллельных запросов)&#x20;

max\_parallel\_workers = ( Cores )

&#x20;max\_parallel\_workers\_per\_gather = ( 2 \* Cores ) / ( Ожидаемое кол-во сессий )

14. &#x20;**wal\_buffers** - определяет обём памяти, для буферизации данных журналов WAL, задаётся обычно как 3% от shared\_buffers, но не более, чем размер одного сегмента WAL(стандартный размер 16 Мб). На нагруженном сервере рекомендуется поставить wal\_buffers = размеру сегмента WAL

Частные случаи:

wal\_buffers = = 16MB # Вариант ручной настройки  для обычного сервера

wal\_buffers = -1 # Доверить базе данных автоматически настраивать значение. По умолчанию

wal\_buffers = 128MB # В случае, если у вашег оклиента 8 и более ядер у процессора

15. **wal\_compression** - определяет будет ли сжиматься страница, записываемая в журнал WAL. Этот параметр помогает сократить время записи в журналы, но накладывает нагрузку на процессор. Как правило лучше выключать. Включил в список, так как online сборщики настроек как правило включают эти настройки, что на тестах наших программ показало себя плохо. Стоит включать только в случае, если WAL почти постоянно в состояние ожидания IO потока(проверяется либо через запросы, либо через dashboard, либо через специальные утилиты типа pgMetrics) или у вас очень хороший процессор.&#x20;

wal\_compression = off

16. работа с размерами WAL:

* checkpoint\_timeout&#x20;
* max\_wal\_size&#x20;
* min\_wal\_size

Три параметра выше задают максимальное время\размер до записи\ перезаписи журнала. Если вы не пишете 1 гб\час в базу и ваша база в логах не указывает, что слишком часто переписывает журналы WAL, то не стоит редактировать эти знрачения. Однако при выосокй нагрузке на базу, можно поднять размеры max\_wal\_size и min\_wal\_size до нескольких ГБ

17. **bg\_writer** - определяет работу фоновой записи. Если процессу потребуется вытеснить страницу из буфера, а страница окажется изменённой, ему придётся самостоятельно писать её на диск. Чтобы этого не происходило синхронно и не приходилось ждать, это происходит в фоновом режиме. Как правило хватает настроек по умолчанию. Добавлена сюда, только из-за того, что онлайн настройщики часто её добавляют.
18. **checkpoint\_completion\_target** - Определяет целевое время для завершения процедуры контрольной точки, как коэффициент для общего времени между контрольными точками. В стандартном конфиге 10ой версии стоит 0.5, но в старших версиях перешли на 0.9, на 10ой версии это тоже работает.

Значение: 0.9



### Заключение.

В целом этих настроек хватает для тонкой настройки среднего сервера без RAID, без нескольких компьютеров внутри одного кластера, без архивации и репликации.







